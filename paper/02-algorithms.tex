\section{Алгоритмы и техники, используемые в переборе}

Для написания программы для перебора был выбран язык программирования Go. Это сравнительно новый язык (появился в 2009 году), который:

\begin{itemize}
    \item Является компилируемым (программы на нём могут достигать производительности программ, написанных на Си);
    \item Безопасно управляет памятью (это упрощает отладку программ по сравнению с Си);
    \item Позволяет легко распараллелить вычисления между ядрами процессора.
\end{itemize}

Реализованная программа параллельно на всех ядрах процессора перебирает и проверяет все строки, начиная от меньших длин к большим. Выводятся все строки, где $ L(S) > Z(S) $. С программой для перебора прилагается вспомогательная утилита, которая показывает разбиения произвольных строк и величины $L(S)$, $Z(S)$ для них.

Для вычисления количества различных сегментов в разбиении Линдона используется алгоритм Дюваля~\cite{Duval-1988}.

Для вычисления количества сегментов в разбиении Лемпеля-Зива используется алгоритм~\cite{Goto-Bannai-2012} (Goto, Bannai, 2012). Для его использования требуется предварительно построить суффиксный массив строки, что делается одним из следующих способов:

\begin{itemize}
    \item Алгоритм~\cite{Larsson-Sadakane-2007} (Larsson, Sadakane, 2007), строящий суффиксный массив за $O(n \log n)$, где $n$ ~--- длина строки. Этот алгоритм уже реализован в стандартной библиотеке Go. Данная реализация была модифицирована так, чтобы работать только со статическими буферами и избежать регулярных выделений памяти (что значительно ускорило программу).
    
    \item Для коротких бинарных строк (чья длина не больше 64) можно использовать другой способ. Бинарную строку можно представить в виде переменной, содержащей одно целое 64-битное число. Суффиксы такой строки можно быстро сравнивать между собой, если выделить их с помощью операции битового сдвига влево (справа они дополнятся нулями), а затем сравнить как 64-битные числа (если они равны, следует также учесть длины суффиксов). Тогда суффиксы будут сравниваться лексикографически с помощью простых для процессора операций за $ O(1) $.
    
    Используя описанный метод сравнения суффиксов по их смещениям, достаточно отсортировать массив со смещениями суффиксов за $ O(n \log n) $ и получить искомый суффиксный массив. На практике этот метод оказался существенно быстрее предыдущего.
\end{itemize}

В итоге первый метод использовался для вычисления разбиений длинных строк (их понадобилось строить, чтобы проверить свойства полученных серий), а второй метод ~--- для разбиения коротких строк во время перебора.

Построение разбиения Лемпеля-Зива всё равно являлось узким местом в программе (оно выполняется значительно медленнее, чем построение разбиения Линдона). Для ускорения программы был использован тот факт, что $ Z(S) = Z(\bar S) $, где $ \bar S $ ~--- строка, полученная из $ S $ заменой всех 0 на 1 и всех 1 на 0. Это позволяет вычислять в два раза меньше разбиений Лемпеля-Зива, что ускорило программу ещё в 1,5--2 раза.

Итоговая версия программы требует $ O(2^n \cdot n \log n) $ времени, чтобы проверить все строки длины $n$. На четырёхядерном процессоре ноутбука Intel Core i5-3317U проверка всех бинарных строк длины 25 занимает около 22 секунд.

Исходный код доступен по ссылке: \url{https://github.com/borzunov/course-work-2016}
